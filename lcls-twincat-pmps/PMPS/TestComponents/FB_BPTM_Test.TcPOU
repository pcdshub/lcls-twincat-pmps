<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_BPTM_Test" Id="{fb9a456e-191d-4018-903c-95799c9aa22a}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'call_after_init'}
FUNCTION_BLOCK FB_BPTM_Test EXTENDS TcUnit.FB_TestSuite
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
END_VAR
VAR CONSTANT
    BPTM_ARR : UDINT := PMPS_PARAM.MAX_ASSERTIONS;
    cCycle : UINT := 20; // How many cycles does it take to complete a BPTM
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[BPTMBasicFunction();
InterruptAtAllSteps();
FullArbError();]]></ST>
    </Implementation>
    <Method Name="BPTMBasicFunction" Id="{70f68025-dfe3-432b-8778-ea5b6ded4985}">
      <Declaration><![CDATA[METHOD BPTMBasicFunction
VAR_INPUT
END_VAR
VAR    
    //Final and transition assertions
    nTransitionID    :    UDINT := 1;
    stTransitionAssertion    :    ST_BeamParams := (nRate := 10);
    
    nReqID    :    UDINT    := 2;
    stReqAssertion    :    ST_BeamParams := (nTran := 20);
    
END_VAR
VAR_INST
    fbBPTM_TestBasicFunction    :    BeamParameterTransitionManager;
    fbArbiter    :    FB_Arbiter(1);
    ffo : FB_HardwareFFOutput;
    fbSubSysIO : FB_DummyArbIO;
    xFirstPass    :    BOOL := TRUE;
    eTestStep: E_BPTMTestStates := E_BPTMTestStates.Init;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Completes arbiter request elevation process
// Necessary for CheckRequest to return true, ever
    fbBPTM_TestBasicFunction(
        fbArbiter := fbArbiter,
        );

fbSubSysIO(LA := fbArbiter, FFO := ffo);

// Note: this struct may also be (over)written to in the tests below, specifically rate.
fbBPTM_TestBasicFunction.stCurrentBeamParameters := fbSubSysIO.q_stSimulatedBPReadback;

CASE eTestStep OF

E_BPTMTestStates.Init:
    
    TEST('BPTMTest');
    eTestStep := E_BPTMTestStates.WaitingForBeam;

E_BPTMTestStates.WaitingForBeam:
    TEST('BPTM Waits for Beam');
    
    fbBPTM_TestBasicFunction.i_TransitionAssertionID := nTransitionID;
    fbBPTM_TestBasicFunction.i_stTransitionAssertion := stTransitionAssertion;
    
    fbBPTM_TestBasicFunction.i_nRequestedAssertionID := nReqID;
    fbBPTM_TestBasicFunction.i_stRequestedAssertion := stReqAssertion;
    
    IF fbBPTM_TestBasicFunction.eBPTMState = E_BPTMState.WaitForBP AND 
        NOT fbBPTM_TestBasicFunction.xEntry THEN
    
        AssertTrue(fbArbiter.CheckRequestInPool(nTransitionID), 'Arbiter did not accept BPTM transition assertion');
        
        AssertTrue(fbArbiter.CheckRequestInPool(nReqID), 'Arbiter did not accept BPTM transition assertion');
                
        AssertFalse(fbBPTM_TestBasicFunction.q_xTransitionAuthorized,
            'Transition should not be authorized until requests are in and beam is ready');
            
        AssertTrue(fbBPTM_TestBasicFunction.bBusy, 'Busy should be true here');
        AssertFalse(fbBPTM_TestBasicFunction.bDone, 'Done should be false');
        AssertFalse(fbBPTM_TestBasicFunction.bError, 'Error should be false here');
            
        TEST_FINISHED_NAMED('BPTM Waits for Beam');
        
        eTestStep := E_BPTMTestStates.Transitioning;
    END_IF    
    
    
E_BPTMTestStates.Transitioning:
    TEST('BPTM Authorizes Transition');

    fbBPTM_TestBasicFunction.stCurrentBeamParameters.nRate := 0; // satisfies the transition request   
    
    IF fbBPTM_TestBasicFunction.eBPTMState = E_BPTMState.Transitioning AND
        NOT fbBPTM_TestBasicFunction.xEntry THEN
    
        AssertTrue(fbArbiter.CheckRequest(nTransitionID),
            'Transition assertion should be in arbiter');
        
        AssertTrue(fbArbiter.CheckRequest(nReqID),
            'Final assertion should be in arbiter');
            
        AssertTrue(fbBPTM_TestBasicFunction.q_xTransitionAuthorized,
            'Transition should be authorized at this point.');
            
        AssertEquals(nReqID, fbBPTM_TestBasicFunction.nCurrentAssertionID,
            'nCurrentAssertionID not set.');
    
        TEST_FINISHED_NAMED('BPTM Authorizes Transition');
        
        eTestStep := E_BPTMTestStates.WaitingForFinalAssertion;
    END_IF

E_BPTMTestStates.WaitingForFinalAssertion:
    TEST('BPTM Waits for final BP');
    
    fbBPTM_TestBasicFunction.i_xDoneMoving := TRUE;
    
    IF fbBPTM_TestBasicFunction.eBPTMState = E_BPTMState.WaitForFinalBP THEN
        
        AssertTrue(fbArbiter.CheckRequest(nTransitionID),
        'Transition assertion should be in arbiter');  
        
        TEST_FINISHED_NAMED('BPTM Waits for final BP');
        
        eTestStep := E_BPTMTestStates.CleaningUp;
    END_IF    
    
E_BPTMTestStates.CleaningUp:

    fbSubSysIO.AutoUpdateBP := TRUE;

    TEST('Cleaning up');
    
    IF fbBPTM_TestBasicFunction.eBPTMState = E_BPTMState.Done THEN
        
        AssertFalse(fbArbiter.CheckRequestInPool(nTransitionID), 'Transition req should be removed from arb now');
        
        eTestStep := E_BPTMTestStates.Done; 
        
        TEST_FINISHED_NAMED('Cleaning up');
	END_IF

E_BPTMTestStates.Done:

    
    AssertTrue(fbBPTM_TestBasicFunction.bDone, 'Done should be set');
    AssertFalse(fbBPTM_TestBasicFunction.bError, 'Error should be cleared');
    AssertFalse(fbBPTM_TestBasicFunction.bBusy, 'Busy should be false');
    
    TEST_FINISHED_NAMED('BPTMTest');    
    
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="FullArbError" Id="{b24cff8a-98df-48c0-95b3-ca157e608fb9}">
      <Declaration><![CDATA[// Simulate error due to full arbiter
METHOD FullArbError
VAR_INPUT
END_VAR
VAR    
    //Final and transition assertions
    nTransitionID    :    UDINT := 1000;
    stTransitionAssertion    :    ST_BeamParams := PMPS_GVL.cstSafeBeam;
    
    nReqID    :    UDINT    := 2000;
    stReqAssertion    :    ST_BeamParams := PMPS_GVL.cstSafeBeam;
    
    idx : UDINT;
    
    nRandID : DWORD;
    testReq : ST_BeamParams := (neVRange := 16#FFEE, nRate:=33);
    
END_VAR
VAR_INST
    fbBPTM_TestFullArb    :    BeamParameterTransitionManager;
    fbArbFullErr    :    FB_Arbiter(1);
    ffo : FB_HardwareFFOutput;
    fbSubSysIO : FB_DummyArbIO;
    fbBPR :  FB_BPRequestor;
    xFirstPass    :    BOOL := TRUE;
    eTestStep: E_BPTMTestStates := E_BPTMTestStates.Init;
    tonRetryTimeout : TON := (PT:=T#5s);
    entryToRetry : bool := true;
    fbRand : DRAND := (Seed :=1);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE eTestStep OF

E_BPTMTestStates.Init:
    
    TEST('BPTMErrorFullArb');
    
    // Fill the arbiter
    FOR idx := 1 TO PMPS_PARAM.MAX_ASSERTIONS // this fills the arbiter
                    - fbBPTM_TestFullArb.cReqArbCapacity + 1 DO // but test just one over the allowed amount
        fbArbFullErr.AddRequest(nReqID := idx, stReqBP := testReq);
    END_FOR
    
    fbSubSysIO.AutoUpdateBP := TRUE;
    
    AssertTrue(PMPS_PARAM.MAX_ASSERTIONS - fbArbFullErr.nEntryCount < fbBPTM_TestFullArb.cReqArbCapacity,
        'Arbiter is not full enough, rest of tests will be invalid'); 
    
    eTestStep := E_BPTMTestStates.Error;

E_BPTMTestStates.Error:
    
    TEST('BPTM Full Error');

    IF fbBPTM_TestFullArb.bError THEN
        
        AssertTrue(fbBPTM_TestFullArb.bError AND fbBPTM_TestFullArb.nErrId = PMPS_CODES.NoRoomInArb,
            'Incorrect error response from full arbiter.');
            
        TEST_FINISHED_NAMED('BPTM Full Error');
        
        eTestStep := E_BPTMTestStates.Retry;
        
	END_IF
    
E_BPTMTestStates.Retry:
    
    TEST('Test Retry Post Failed Final');
    
    // Clear the arbiter
    if entryToRetry THEN
        FOR idx := 1 TO PMPS_PARAM.MAX_ASSERTIONS + 1 DO
            fbArbFullErr.RemoveRequest(idx);
        END_FOR
        entryToRetry := FALSE;
    END_IF
    
    // Push the retry button
    fbBPTM_TestFullArb.bRetry := TRUE;
    
    tonRetryTimeout(IN:=TRUE);
    
    IF tonRetryTimeout.Q OR fbBPTM_TestFullArb.q_xTransitionAuthorized THEN
        AssertTrue(fbBPTM_TestFullArb.q_xTransitionAuthorized, 'Transition should have been authorized by now');
        AssertTrue(fbArbFullErr.CheckRequest(nTransitionID), 'Transition ID is missing from arbiter while transition is authorized');
        AssertTrue(fbArbFullErr.CheckRequest(nReqID), 'Final ID is missing from arbiter while transition is authorized');
        
        TEST_FINISHED_NAMED('Test Retry Post Failed Final');
        
        eTestStep := E_BPTMTestStates.CleaningUp;
	END_IF

E_BPTMTestStates.CleaningUp:
    TEST_FINISHED_NAMED('BPTMErrorFullArb');    
    
END_CASE

fbBPTM_TestFullArb(
    fbArbiter := fbArbFullErr,
    i_TransitionAssertionID := nTransitionID,
    i_stTransitionAssertion := stTransitionAssertion,
    
    i_nRequestedAssertionID := nReqID,
    i_stRequestedAssertion := stReqAssertion,
    
    stCurrentBeamParameters := fbSubSysIO.q_stSimulatedBPReadback,
);

fbSubSysIO(LA := fbArbFullErr, FFO := ffo);]]></ST>
      </Implementation>
    </Method>
    <Method Name="InterruptAtAllSteps" Id="{57f1a367-2f35-4862-95b6-e41c9bfb9e3f}">
      <Declaration><![CDATA[// Test the BPTM seamlessly handles new requests at any stage
// Verify old requests are removed from arbiter
METHOD InterruptAtAllSteps
VAR_INPUT
END_VAR
VAR    
    //Final and transition assertions
    nTransitionID    :    UDINT := 16#DAAD;
    stTranReq    :    ST_BeamParams := PMPS_GVL.cst0RateBeam;
    
    nFirstReqID    :    UDINT    := 16#FEED;
    stFirstReq    :    ST_BeamParams := (nRate := 16#FEED);
    
END_VAR
VAR_INST
    fbBPTM_InterruptionTest    :    BeamParameterTransitionManager;
    
    ffo : FB_HardwareFFOutput := (bAutoReset:=TRUE);
    fbSubSysIO : FB_DummyArbIO;
    fbBPR :  FB_BPRequestor;
    xFirstPass    :    BOOL := TRUE;
    eTestStep: E_BPTMTestStates := E_BPTMTestStates.Init;
    tonRetryTimeout : TON := (PT:=T#5s);
    
    fbBPTMDiscCycles : BeamParameterTransitionManager;
    fbSubSysIODisc : FB_DummyArbIO;
    fbArbDisc : FB_Arbiter(1000);
    
    iCount : UINT;
    
    aBPTM : ARRAY [1..cCycle] OF BeamParameterTransitionManager;
    BPTMUnderTest : REFERENCE TO BeamParameterTransitionManager;
    fbArbiter    :    FB_Arbiter(1);
    aArbIO : ARRAY [1..cCycle] OF FB_DummyArbIO;
    ArbIO : REFERENCE TO FB_DummyArbIO;
    nCycleLim : UINT;
    nCycle : UINT;
    sCurrentTestName : STRING :='';
    bCycleLimHit : BOOL; 
    nAllStepsDone : BYTE;
    tTimeOut : TON := (PT:=T#20ms);
        
    bTestedOnce : BOOl;
END_VAR
VAR CONSTANT
    nNewTarget : INT := 0;
    nRequestBP : INT := 1;
    nWaitForBP : INT := 2;
    nTransitioning : INT := 3;
    nWaitForFinalBP : INT := 4;
    nCleaningUp : INT := 5;
    nDone : INT := 6;
    nIdle : INT := 7;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
(* These tests will confirm the BPTM is interruptable at any step,
meaning it will not deadlock or stall, and will always complete with
the correct sequencing *)

(* This functionality is crucial as a deadlocked BPTM will need manual intervention,
users of the BPTM should always be able to just set a target BP that is easy to reach
at any point in time, and have the BPTM head in that direction and succeed. *)

// Determine how many cycles it would take normally, to complete a full BPTM cycle
// This count will be verified against the current count constant

IF NOT bTestedOnce THEN

TEST('CheckBPTM Cycle Count');

WHILE fbBPTMDiscCycles.eBPTMState <> E_BPTMState.Idle DO
    
    fbBPTMDiscCycles.i_TransitionAssertionID := nTransitionID;
    fbBPTMDiscCycles.i_stTransitionAssertion := stTranReq;
    
    fbBPTMDiscCycles.i_nRequestedAssertionID := nFirstReqID;
    fbBPTMDiscCycles.i_stRequestedAssertion := stFirstReq;
    
    fbBPTMDiscCycles(fbArbiter:=fbArbDisc);
    fbSubSysIODisc(LA:=fbArbDisc, FFO:=ffo);
    
    fbBPTMDiscCycles.stCurrentBeamParameters := fbSubSysIODisc.q_stSimulatedBPReadback;
    
    fbSubSysIODisc.AutoUpdateBP := TRUE;
    
    fbBPTMDiscCycles.i_xDoneMoving S= fbBPTMDiscCycles.q_xTransitionAuthorized;
    
    iCount := iCount + 1;
END_WHILE

IF fbBPTMDiscCycles.eBPTMState = E_BPTMState.Idle THEN
    AssertTrue(cCycle >= iCount, CONCAT('cCycle is too low, increase it to', INT_TO_STRING(iCount)));
    TEST_FINISHED_NAMED('CheckBPTM Cycle Count');
END_IF

// Run BPTM for nCycleLim cycles, switch to a new target, verify BPTM completes anyways

FOR nCycleLim := 1 TO cCycle DO
    
    nCycle := 0;
    
    bCycleLimHit := FALSE;
    
    BPTMUnderTest REF= aBPTM[nCycleLim];
    ArbIO REF= aArbIO[nCycleLim];
    
    BPTMUnderTest.i_TransitionAssertionID := nTransitionID;
    BPTMUnderTest.i_stTransitionAssertion := stTranReq;
    
    ArbIO.AutoUpdateBP := TRUE;
    
    // Start the test for this Cycle Limit
    sCurrentTestName := CONCAT('CycleLimTest:',INT_TO_STRING(nCycleLim));
    TEST(sCurrentTestName);
    
    nAllStepsDone := 0;
    
    tTimeOut(IN:=FALSE);
        
    WHILE nAllStepsDone <> 16#FF DO
        
        tTimeOut(IN:= TRUE);

        IF tTimeOut.Q THEN
            AssertTrue(FALSE, CONCAT('Failed ', BYTE_TO_HEXSTR(nAllStepsDone, 2, FALSE)));
            EXIT;
        END_IF  
    
        // Verify all steps complete
        IF bCycleLimHit THEN
            nAllStepsDone.nNewTarget S= BPTMUnderTest.eBPTMState = E_BPTMState.NewTarget;
            nAllStepsDone.nRequestBP S= BPTMUnderTest.eBPTMState = E_BPTMState.RequestBP;
            nAllStepsDone.nWaitForBP S= BPTMUnderTest.eBPTMState = E_BPTMState.WaitForBP;
            nAllStepsDone.nTransitioning S= BPTMUnderTest.eBPTMState = E_BPTMState.Transitioning;
            nAllStepsDone.nWaitForFinalBP S= BPTMUnderTest.eBPTMState = E_BPTMState.WaitForFinalBP;
            nAllStepsDone.nCleaningUp S= BPTMUnderTest.eBPTMState = E_BPTMState.CleaningUp;
            nAllStepsDone.nDone S= BPTMUnderTest.eBPTMState = E_BPTMState.Done;
            nAllStepsDone.nIdle S= BPTMUnderTest.eBPTMState = E_BPTMState.Idle;
        ELSE
            nAllStepsDone := 0;
		END_IF
    
        // After nCycleLim cycles (nCycle), change the target
        IF nCycle >= nCycleLim THEN
            BPTMUnderTest.i_nRequestedAssertionID := nCycleLim;
            BPTMUnderTest.i_stRequestedAssertion.nRate := nCycleLim;
            bCycleLimHit := TRUE;
        ELSE
            BPTMUnderTest.i_nRequestedAssertionID := nFirstReqID;
            BPTMUnderTest.i_stRequestedAssertion := stFirstReq;
		END_IF
        
        BPTMUnderTest(fbArbiter:=fbArbiter);
        ArbIO(LA:=fbArbiter, FFO := ffo);
        
        BPTMUnderTest.stCurrentBeamParameters := ArbIO.q_stSimulatedBPReadback;
        
        BPTMUnderTest.i_xDoneMoving := BPTMUnderTest.q_xTransitionAuthorized;
        
        nCycle := nCycle + 1;
    
	END_WHILE
    
    AssertTrue(fbArbiter.CheckRequestInPool(BPTMUnderTest.i_nRequestedAssertionID),
        CONCAT('Final req not in pool: ', UINT_TO_STRING(nCycleLim)));
    AssertFalse(fbArbiter.CheckRequestInPool(BPTMUnderTest.i_TransitionAssertionID),
        'TransReq still in pool');
    AssertFalse(fbArbiter.CheckRequestInPool(nFirstReqID),
        'First req still in pool');
    AssertTrue(bCycleLimHit,
        CONCAT('Cycle lim not hit', UINT_TO_STRING(nCycleLim)));
    AssertTrue(ArbIO.q_stSimulatedBPReadback.nRate = BPTMUnderTest.i_stRequestedAssertion.nRate,
        'Rates are not equal...');
    
    TEST_FINISHED_NAMED(sCurrentTestName);
    
    // Clean up for next test
    
    fbArbiter.RemoveRequest(nFirstReqID);
    fbArbiter.RemoveRequest(nTransitionID);
    fbArbiter.RemoveRequest(nCycleLim);
    
END_FOR

END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="InterruptedTransition" Id="{52bafcb8-58c7-428b-9676-0a0ae9d5b89b}">
      <Declaration><![CDATA[// Test the BPTM seamlessly handles new requests at any stage
// Verify old requests are removed from arbiter
METHOD InterruptedTransition
VAR_INPUT
END_VAR
VAR    
    //Final and transition assertions
    nTransitionID    :    UDINT := 3;
    stTranReq    :    ST_BeamParams := PMPS_GVL.cstSafeBeam;
    
    nFirstReqID    :    UDINT    := 1;
    stFirstReq    :    ST_BeamParams := (nRate := 100);
    
    nSecondReqID    :    UDINT    := 2;
    stSecReq    :    ST_BeamParams := (nRate:= 200);
    
END_VAR
VAR_INST
    fbBPTM_InterruptionTest    :    BeamParameterTransitionManager;
    fbArbiter    :    FB_Arbiter(1);
    ffo : FB_HardwareFFOutput;
    fbSubSysIO : FB_DummyArbIO;
    fbBPR :  FB_BPRequestor;
    xFirstPass    :    BOOL := TRUE;
    eTestStep: E_BPTMTestStates := E_BPTMTestStates.Init;
    tonRetryTimeout : TON := (PT:=T#5s);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE eTestStep OF

E_BPTMTestStates.Init:
    
    TEST('BPTM Intr Trans');
    
    fbBPTM_InterruptionTest.i_TransitionAssertionID := nTransitionID;
    fbBPTM_InterruptionTest.i_stTransitionAssertion := stTranReq;
    
    fbBPTM_InterruptionTest.i_nRequestedAssertionID := nFirstReqID;
    fbBPTM_InterruptionTest.i_stRequestedAssertion := stFirstReq;
    
    fbSubSysIO.AutoUpdateBP := TRUE; // Enable auto update
    
    eTestStep := E_BPTMTestStates.WaitingForTransitionAssertion;

E_BPTMTestStates.WaitingForBeam:

    IF fbBPTM_InterruptionTest.eBPTMState = E_BPTMState.WaitingForTransitionAssertion AND 
        NOT fbBPTM_InterruptionTest.xEntry THEN // since we're not in entry anymore 
    
        //change the request to interrupt
        fbBPTM_InterruptionTest.i_nRequestedAssertionID := nSecondReqID;
        fbBPTM_InterruptionTest.i_stRequestedAssertion := stSecReq;
        
        eTestStep := E_BPTMTestStates.Transitioning;
    END_IF
    
E_BPTMTestStates.Transitioning:
    
    TEST('New Target Gets To Trans Auth');
    
    tonRetryTimeout(IN:=TRUE);
    
    IF tonRetryTimeout.Q OR fbBPTM_InterruptionTest.q_xTransitionAuthorized THEN
        AssertTrue(fbBPTM_InterruptionTest.q_xTransitionAuthorized, 'Transition should have been authorized by now');
        AssertTrue(fbArbiter.CheckRequest(nTransitionID), 'Transition ID is missing from arbiter while transition is authorized');
        AssertTrue(fbArbiter.CheckRequest(nSecondReqID), 'Final ID is missing from arbiter while transition is authorized');
        
        TEST_FINISHED_NAMED('New Target Gets To Trans Auth');
        
        eTestStep := E_BPTMTestStates.CleaningUp;
	END_IF

E_BPTMTestStates.CleaningUp:
    TEST_FINISHED_NAMED('BPTM Intr Trans');    
    
END_CASE

fbBPTM_InterruptionTest(
    fbArbiter := fbArbiter,
    stCurrentBeamParameters := fbSubSysIO.q_stSimulatedBPReadback
);

fbSubSysIO(LA := fbArbiter, FFO := ffo);]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>