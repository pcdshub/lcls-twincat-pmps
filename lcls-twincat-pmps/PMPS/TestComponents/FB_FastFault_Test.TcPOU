<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_FastFault_Test" Id="{2ec3826d-e723-4fb3-ae0d-bdcd8662dc40}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'call_after_init'}
FUNCTION_BLOCK FB_FastFault_Test EXTENDS TcUnit.FB_TestSuite
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	fbTime : FB_LocalSystemTime := ( bEnable := TRUE, dwCycle := 1 ); //fbTime : NT_GetTime; //Get current system time, used for override
END_VAR
VAR CONSTANT
    OvrdTime : TIME := T#2s;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[FFCombinedFunctionality();
FFRegistration();
FFOvrdAndNextFault();]]></ST>
    </Implementation>
    <Method Name="FFCombinedFunctionality" Id="{a87e81fa-eb2b-44b4-80d9-4461fa087530}">
      <Declaration><![CDATA[METHOD FFCombinedFunctionality
VAR_INPUT
END_VAR
VAR_INST
    fbFF    :    FB_FastFault;
    fbFFO    :    FB_HardwareFFOutput;
    
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('FFCombinedFunctionality');

//Clear initial faults
fbFFO.i_xReset:=TRUE; //Reset requested at start of cycle

fbFF(io_fbFFHWO := fbFFO, //FF reset somehwere in code
    i_xOK := TRUE,
    i_xReset := TRUE);

fbFFO.EvaluateOutput(); //FFO eval called at end of cycle
    
AssertTrue(fbFFO.q_xFastFaultOut,
    'Fast fault did not clear');


//Induce fault with FF

fbFFO(i_xReset := FALSE); //Reset released at start of cycle

fbFF(io_fbFFHWO := fbFFO, //FF faulted
    i_xOK := FALSE); //Reset is still set true from last call.
    
fbFFO.EvaluateOutput(); //FFO eval called at end of cycle

AssertFalse(fbFFO.q_xFastFaultOut,
    'Fast fault did not trip the beam');
    
    
//FFO remains faulted until local (FF) and FFO receieve fresh reset request, and faults
//are actually cleared

//Attempt to clear FFO fails because FF still faulted
fbFFO.i_xReset := TRUE; //Reset requested

fbFF(io_fbFFHWO := fbFFO, //FF faulted
    i_xOK := FALSE,
    i_xReset := FALSE);
    
fbFFO.EvaluateOutput(); //FFO eval called at end of cycle

AssertFalse(fbFFO.q_xFastFaultOut,
    'Fast fault output cleared while fault remains, very bad');
    
//Attempt to clear FF while fault remains fails
fbFFO.EvaluateOutput(i_xReset := FALSE);

fbFFO.i_xReset := TRUE; //Reset requested

fbFF(io_fbFFHWO := fbFFO, //FF faulted
    i_xOK := FALSE,
    i_xReset := TRUE); //This reset should fail.
    
fbFFO.EvaluateOutput(); //FFO eval called at end of cycle

AssertFalse(fbFFO.q_xFastFaultOut,
    'Fast fault cleared while fault remains, very bad');
    
TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="FFOvrdAndNextFault" Id="{b17e0363-eca4-4d26-afa9-1c5d39a76914}">
      <Declaration><![CDATA[METHOD FFOvrdAndNextFault
VAR_INPUT
END_VAR
VAR_INST
    fbFF    :    FB_FastFault :=(
        i_xAutoReset := TRUE);
    fbFFO    :    FB_HardwareFFOutput := (
        bAutoReset := TRUE);
    rFF : REFERENCE TO ST_FF;
    
    FirstPass : BOOL := TRUE;
    OvrdActvTstDone : BOOL := FALSE;
    
    TestsDone : BOOL := FALSE;
	Now: DATE_AND_TIME;
	Expiration : DINT; 
	OvdTime : TIME ;
	Expire: TIMESTRUCT;
//seconds:ULINT;
	specificLocalTimeToFileTime : FB_TzSpecificLocalTimeToFileTime;
    fileTime: T_FILETIME;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('FFVetoAndNextFault');
fbTime();
// I noticed something weird going on with the PEWatcher on the L line. It was faulted, and the fast fault
// was not tripping off beam. It had been previously overridden so I was wondering why it wasn't causing a trip.

IF FirstPass  THEN

    fbFF(io_fbFFHWO := fbFFO, //FF reset somehwere in code
        i_xOK := TRUE);
    
    fbFFO.ExecuteNoLog(); //FFO eval called at end of cycle
        
    AssertTrue(fbFFO.q_xFastFaultOut,
        'Fast fault did not clear');
    
    
    //Induce fault with FF
    
    fbFF(io_fbFFHWO := fbFFO, //FF faulted
        i_xOK := FALSE); 
        
    fbFFO.ExecuteNoLog(); //FFO eval called at end of cycle
    
    AssertFalse(fbFFO.q_xFastFaultOut,
        'Fast fault did not trip the beam');


    rFF REF= fbFFO.astFF[fbFF.RegistrationIdx];


	Now := SystemTime_TO_DT(fbTime.systemTime);
	Expire:= fbTime.systemTime;
	Expire.wSecond:= Expire.wSecond+5;
	specificLocalTimeToFileTime(in := Tc2_Utilities.SYSTEMTIME_TO_FILETIME(Expire), tzInfo := , out => fileTime);
	Expiration := TO_DINT((SHL(DWORD_TO_ULINT(fileTime.dwHighDateTime), 32) + DWORD_TO_ULINT(fileTime.dwLowDateTime)) / 10000000 - 11644473600);;

	//Expiration.:= SystemTime_TO_DT(fbTime.TIMESTR);//+TO_DT(OvrdTime);//TO_DT(OvrdTime));//1652385896;
    // Overrides set from EPICS
	//rFF.Ovrd.Expiration := Expiration;
    WRITE_PROTECTED_DINT(ADR(rFF.Ovrd.Expiration), Expiration );
    WRITE_PROTECTED_BOOL(ADR(rFF.Ovrd.Activate), TRUE);
    
    
    IF fbTime.bValid THEN FirstPass := FALSE; END_IF
    
END_IF

// On every cycle:
fbFF(io_fbFFHWO := fbFFO, //FF faulted
    i_xOK := FALSE); 
    
fbFFO.ExecuteNoLog(); //FFO eval called at end of cycle


IF rFF.Ovrd.Active AND rFF.BeamPermitted THEN

    AssertTrue(fbFFO.q_xFastFaultOut,
        'Fast fault should be overridden so FFO should be true');
    
    OvrdActvTstDone := TRUE;
END_IF

IF OvrdActvTstDone and NOT rFF.Ovrd.Active and not rff.BeamPermitted THEN
    
    AssertFalse(fbFFO.q_xFastFaultOut,
        'Fast fault override expired so beam should be off.');
   // AssertFalse(rFF.BeamPermitted, 'Beam should not be permitted now');
    
    TestsDone := TRUE;
END_IF


IF TestsDone THEN    
    TEST_FINISHED_NAMED('FFVetoAndNextFault');
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FFRegistration" Id="{3ff41afd-9e3c-4c36-9c04-7ce787b90bc6}">
      <Declaration><![CDATA[METHOD FFRegistration
VAR_INPUT
END_VAR
VAR_INST
    fbFF    :    FB_FastFault;
    fbFFO    :    FB_HardwareFFOutput;
    astFF : ARRAY[0..10] OF ST_FF;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('FFRegistration');

fbFF(io_fbFFHWO := fbFFO);

AssertEquals_STRING(fbFF.sPath, fbFFO.astFF[fbFF.RegistrationIdx].Info.sPath,
    'FF registration with FFO did not succeed');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>